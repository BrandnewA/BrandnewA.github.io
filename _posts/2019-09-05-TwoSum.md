---
layout:     post
title:      LeetCode--Two-Sum
subtitle:   总结
date:       2019-09-05
author:     BrandnewA
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - C++
    - Two-sum
    - 数据结构
    - 编程
--- 

# 前言
```

```

### Two-Sum 问题 1

```
给出一个整数数组，请在数组中找出两个加起来等于目标值的数，
你给出的函数twoSum 需要返回这两个数字的下标（index1，index2），需要满足 index1 小于index2.。
注意：下标是从1开始的
假设给出的数组中只存在唯一解
```

#### 示例:
```
给出的数组为 {2, 7, 11, 15},目标值为9
输出 ndex1=1, index2=2
```


### Hash+查询解法
#### 思路说明:
```
step1 建立一个hash表
step2 从左到右遍历数组，将遍历过的数组元素nums[i]作为关键值存放在hash表中，查找hash表中是否有关键值=target-nums[i]的
```
#### 代码实现：
```
- [哈希表法解析](https://blog.csdn.net/qq_38451119/article/details/83749165)
        
```

### Two-Sum 问题 2
```
上一题的改进版，给一个数组，还有一个元素target，找出数组里面有多少对元素之和大于target.
```

#### 示例 1:
```
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]

```

#### 示例 2:
```
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]
```

#### 说明:
```
输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。
```

### 排序数组+双指针扫描解法
#### 思路说明:
```
step1 数组从小到大排序 sort
step2 指针i从左到右遍历，指针j从右到左遍历：
     (1)nums[i] + nums[j] = 9，则说明有 (j-i) 个组合满足大于target的条件，j--
     (2)nums[i] + nums[j] > 9，则说明有 (j-i) 个组合满足大于target的条件，j--
     (3)nums[i] + nums[j] < 9，则继续向右扫描 i++
时间复杂度：排序O(nlogn),遍历O(n)-->O(nlogn)
空间复杂度：O(1)
```
#### 代码实现

```
class Solution {
    public int twoSum2(int[] nums, int target) {
        Array.sort(nums);
        int left = 0;
        int right = nums.length - 1;
        int pairs = 0;
        while(left < right)
        {
           if(nums[right] + nums[left] > target)
           {
              pairs = pairs + (right - left);
              right--;
           }
           else
              left++;
        }
        return pairs;
    }
}
```

### Two-Sum 变形之 Triangle Count
```
上一题的改进版，给一个数组，还有一个元素target，找出数组里面有多少对元素之和大于target.
```

#### 示例 1:
```
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]

```

#### 示例 2:
```
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]
```

#### 说明:
```
输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。
```

### 排序数组+双指针扫描解法
#### 思路说明:
```
step1 数组从小到大排序 sort
step2 指针i从左到右遍历，指针j从右到左遍历：
     (1)nums[i] + nums[j] = 9，则说明有 (j-i) 个组合满足大于target的条件，j--
     (2)nums[i] + nums[j] > 9，则说明有 (j-i) 个组合满足大于target的条件，j--
     (3)nums[i] + nums[j] < 9，则继续向右扫描 i++
时间复杂度：排序O(nlogn),遍历O(n)-->O(nlogn)
空间复杂度：O(1)
```
#### 代码实现

```
class Solution {
    public int twoSum2(int[] nums, int target) {
        Array.sort(nums);
        int left = 0;
        int right = nums.length - 1;
        int pairs = 0;
        while(left < right)
        {
           if(nums[right] + nums[left] > target)
           {
              pairs = pairs + (right - left);
              right--;
           }
           else
              left++;
        }
        return pairs;
    }
}
```





### 分析总结
```
数据结构之
hash：只可以查找某个关键值是否存在，是否存在某个=target的关键值,只能定点查找等于target的元素而不能查找大于或者小于target的元素
平衡二叉树和线段树可以用来找出有多少个元素是大于target的

技巧之
对于数组首先排序
对于排序数组可以考虑双指针法（一个从头到尾遍历，一个从尾到头遍历，双指针相遇则停止遍历)

```
### 关于无序映射
- [unordered_map的用法](https://blog.csdn.net/qq_38451119/article/details/83749648)
