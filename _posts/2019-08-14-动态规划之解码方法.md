---
layout:     post
title:      LeetCode--动态规划
subtitle:   解码方法之解码方法的总数
date:       2019-08-14
author:     BrandnewA
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - C++
    - 动态规划
    - 编程
--- 

### 题目 1
一条包含字母 A-Z 的消息通过以下方式进行了编码：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```
给定一个只包含数字的非空字符串，请计算解码方法的总数。

#### 示例 1:
```
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
```

#### 示例 2:

```
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

```

### 一种解法

```
class Solution {
public:
    int numDecodings(string s) {
        //------------------划分型动态规划-------------------
        // step1 子问题：需要知道数字串S前i-1个字符和前i-2个字符的解码方式数
        /*
           状态：设数字串前i个字符的解码方式数=f[i]
           转移方程： f[i] = f[i-1]&&S[i-1]对应一个字母 + f[i-2]&&S[i-1]S[i-2]对应一个字母
        */
        
        // step2 
        /*
           初始条件： f[0] = 1，即空串只有1种解码方式
           边界条件： 如果i=1, 只看最后一个数字 
        */
        
        //时间复杂度=空间复杂度=O(N)
        
        int n= s.size();
        if(n == 0)
            return 0;
        vector<int> f(n+1);
        int i, t;
        
        f[0] = 1;
        // 前i个字符串有多少种解码方式
        for(i = 1; i <= n; ++i)
        {
            f[i] = 0;
            t = s[i-1] - '0';
            if(t >= 1 && t <= 9)
                f[i] = f[i-1];
            if(i >= 2 && (s[i-2]-'0') != 0)
            {
                t = (s[i-2]-'0')*10 + (s[i-1]-'0');
                if(t >= 1 && t <= 26)
                    f[i] += f[i-2];
            }
        }
        if ((s[0]-'0') == 0)
            return 0;
        else
            return f[n];
    }
}; 
```
