---
layout:     post
title:      LeetCode--动态规划
subtitle:   粉刷房子之最少需要花多少钱粉刷房子
date:       2019-08-14
author:     BrandnewA
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - C++
    - 动态规划
    - 编程
--- 

### 题目 1
```
假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。

例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。

注意：所有花费均为正整数。
```


#### 示例 1:
```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

#### 示例 2:

```
输入: m = 7, n = 3
输出: 28
```

#### 说明:
说明：m 和 n 的值均不超过 100。

### 一种解法

```
class Solution {
public:
    int minCost(vector<vector<int>>& costs) {
        
        //----------------序列型动态规划---------------------
        
        // step1 确定状态
        // 子问题：求前n栋房子并且n-1栋房子是红色、蓝色、绿色的最小花费
        /*
           如果直接用以前的思路：则记录油漆前n-1栋房子的最小花费
           但是，前n-1栋房子的最小花费的最优策略中，不知道房子n-2是什么颜色，如果撞色了就不符合要求
           因此，需要记录房子n-2的颜色
        */
        // 因此分别记录粉刷前n-1栋房子并且房子n-2为红色、蓝色、绿色的最小花费
        // 状态：设粉刷前i栋房子并且i-1栋房子是红色、蓝色、绿色的最小花费: f[i][0],f[i][1],f[i][2]
        //转移方程：
        /*
           f[i][0] = min {f[i-1][1] + cost[i-1][0], f[i-1][2]+ cost[i-1][0]}
           f[i][1] = min {f[i-1][0] + cost[i-1][1], f[i-1][2]+ cost[i-1][1]}
           f[i][2] = min {f[i-1][0] + cost[i-1][2], f[i-1][1]+ cost[i-1][2]}
        */
        
        // step2 初始条件
        /*
           f[0][0]=f[0][1]=f[0][2]=0
        */
        
        // 时间复杂度=空间复杂度= O(N)
        
        
        if (costs.empty() || costs[0].empty()) return 0;
        int n = costs.size();
        vector< vector<int> > f((n+1), vector<int>(3));        
        int i, j, k, res;
        f[0][0] = f[0][1] = f[0][2] = 0;
        for(i = 1; i <= n; ++i) // 注意：这里如果是 i<n+1 的话，leetcode会报下标越界的错
        {
            for(j = 0; j < 3; ++j)
            {
                f[i][j] = 1000;
                for(k = 0; k < 3; ++k)
                {
                    if(j == k)
                        continue;
                    if((f[i-1][k] + costs[i-1][j]) < f[i][j])
                    {
                        f[i][j] = f[i-1][k] + costs[i-1][j];
                    }
                }
            }                                
        }
        res = f[n][0];
        if(f[n][1] < res)
          res = f[n][1];
        if(f[n][2] < res)
          res = f[n][2];
        return res;        
    }
};
```


